import { prisma } from "../prisma"\nimport { Prisma } from "../../../lib/generated/prisma"\nimport type { Market, Event, Prediction } from "../../../lib/generated/prisma";\nimport { serializeDecimals } from "@/lib/serialization"\nimport type { MarketDTO } from "@/lib/types"\nimport { Category } from "@/lib/generated/prisma"\n\n// Market queries\nexport const marketQueries = {\n  // ... existing code ...\n  /**\n   * Get top markets by volume whose events end within a specified time range\n   */\n  getMarketsByVolumeAndEndDate: async (\n    rangeStart: Date,\n    rangeEnd: Date,\n    topMarketsCount: number = 10,\n    categoryMix: boolean = false,\n    excludeCategories?: Category[]\n  ) => {\n    if (categoryMix) {\n      // For category mix, we need to include the category in our query\n      const marketsInRange = await prisma.market.findMany({\n        where: {\n          event: {\n            endDate: {\n              gte: rangeStart,\n              lte: rangeEnd,\n            },\n          },\n        },\n        orderBy: { volume: "desc" },\n        include: {\n          event: true, // Include the full event to get category\n        },\n      })\n      \n      return marketsInRange\n    }\n\n    // For standard query (no category mix), also include the full event\n    const whereClause = {\n      event: {\n        endDate: {\n          gte: rangeStart,\n          lte: rangeEnd,\n        },\n        ...(excludeCategories && excludeCategories.length > 0 ? { category: { notIn: excludeCategories } } : {}),\n      },\n    }\n\n    return await prisma.market.findMany({\n      where: whereClause,\n      orderBy: { volume: "desc" },\n      take: topMarketsCount,\n      include: {\n        event: true, // Include the full event\n      },\n    })\n  },\n}
