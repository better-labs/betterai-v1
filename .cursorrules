# Cursor AI Configuration for BetterAI Project

## Project Overview
This is a Next.js prediction market application that integrates with Polymarket and Colosseum APIs. The app uses Prisma with PostgreSQL for data management.

**Infrastructure:** The entire application runs on Vercel infrastructure, including hosting, serverless functions, and database connections.

## Code Style & Patterns
- Use TypeScript with strict typing
- Follow Next.js 14+ App Router patterns
- Use Prisma for database operations
- Prefer functional components with hooks
- Use shadcn/ui components for UI consistency
- Follow the existing file structure and naming conventions

### Running the development server
- If the development server port localhost:3000 is already in use, please do not try to start another development server automatically. Ask first before starting another development server.

### Testing Cron Endpoints
- Use `Authorization: Bearer $CRON_SECRET` header when testing cron endpoints manually
- Example: `curl -H "Authorization: Bearer your-secret" http://localhost:3000/api/cron/endpoint-name`
- Extract CRON_SECRET from .env.local: `grep CRON_SECRET .env.local | cut -d'"' -f2`

### Testing Vercel Cron Jobs Locally
To test the exact same authentication that Vercel Cron will use in production:
```bash
# Extract secret from environment
CRON_SECRET=$(grep CRON_SECRET .env.local | cut -d'"' -f2)

# Test exactly like Vercel Cron will call it
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/daily-update-polymarket-data
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/daily-generate-batch-predictions
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/prediction-check
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/update-ai-models
```

## Database Guidelines
- Wait for user confirmation before moving forward with changes to the Database schema. Ask for user confirmation before moving forward.
- Always use Prisma queries from `lib/db/queries.ts`
- Add new queries to the appropriate query object
- Use transactions for multi-step database operations
- Follow the existing schema patterns (snake_case for DB columns, camelCase for JS)
- Try to use the migration commands in package.json such as "db:migrate:deploy"
### Database Operations
- Use commands in package.json where possible for database migration in Dev and Preview builds.

## API Design
- Use Next.js API routes in `app/api/`
- All cron endpoints (`/api/cron/*`) must require authentication via `CRON_SECRET`
- Use `Authorization: Bearer $CRON_SECRET` header for cron authentication
- Implement maximum batch limits (typically 50-100) to prevent resource exhaustion
- Return consistent `ApiResponse` format
- Include proper error handling and logging
- Use appropriate HTTP status codes

## Raw Data Storage
- Store raw API responses in separate `_raw` tables
- Use JSON columns for raw response data
- Include metadata: marketId, eventId, apiEndpoint, responseStatus, fetchedAt
- Keep raw data for historical purposes only
- Use the canonical `markets` table for application logic

## File Organization
- Components: `components/` (reusable) and `app/` (page-specific)
- Services: `lib/services/` for business logic
- Database: `lib/db/` for queries and schema
- Types: `lib/types.ts` for shared interfaces
- Utils: `lib/utils.ts` for helper functions

## Error Handling
- Use try-catch blocks with proper error logging
- Return structured error responses
- Include meaningful error messages for debugging

## Performance Considerations
- Use database indexes for common query patterns
- Implement proper caching strategies
- Optimize API calls with rate limiting
- Clean up old raw data periodically

## Security
- Validate all user inputs
- Use environment variables for sensitive data
- Implement proper authentication for cron jobs
- Sanitize data before database operations

## Testing
- Write unit tests for business logic
- Test API endpoints with proper error cases
- Validate database operations

## Documentation
- Be concise where possible
- Add JSDoc comments for complex functions
- Add at least a single line comment to explain each major section of code.
- Update README.md for new features
- Document API endpoints and data structures

## Environment Variables
- Always leverage .env.local instead of .env. Do not create a .env file.
- Update .env.example to include new variables.
- **NEVER** pull down production environment variables automatically. Always ask the user for specific values if production env vars are needed.
- Use development environment variables by default: `vercel env pull .env.local --environment=development`

## General Guidance
- Use best practices where possible.
- Prefer minimal code where possible.
- Prefer using existing popular libraries and frameworks for solutions rather than custom code where possible. Please suggest and ask for feedback where existing libraries can be used.