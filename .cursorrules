# Cursor AI Configuration for BetterAI Project

## Project Overview
This is a Next.js prediction market application built by a **solo founder** that integrates with Polymarket and Colosseum APIs. The app uses Prisma with PostgreSQL for data management.

**Infrastructure:** The entire application runs on Vercel infrastructure, including hosting, serverless functions, and database connections. Please see RUNBOOK.md for more information.



## High level guidance to Claude on coding and design
**Solo Founder Context**: This project is built and maintained by a single developer. Prioritize:
- **Simplicity over complexity** - Choose straightforward solutions that are easy to maintain
- **Less code is better** - Choose solutions that involve less custom code where possible.
- **Proven technologies** - Use well-established libraries and patterns
- **Minimal dependencies** - Avoid over-engineering for a 1-person team
- **Clear documentation** - Write code that's easy to understand and modify later
- **Gradual scaling** - Start simple, optimize later when needed


## Code Style & Patterns
- Use TypeScript with strict typing
- Follow Next.js 14+ App Router patterns
- Use Prisma for database operations
- Prefer functional components with hooks
- Use shadcn/ui components for UI consistency
- Follow the existing file structure and naming conventions
- **Keep it simple** - Avoid over-engineering for a solo founder project

### UI/UX Patterns
- **Collapsible Content with Gradient Fade**: For long text content that needs to be collapsed, use gradient fade effects to indicate there's more content below:
  ```jsx
  // Collapsed content with fade effect
  <div className={cn(
    "relative overflow-hidden",
    !expanded && "max-h-[5rem]"
  )}>
    {content}
    {!expanded && (
      <div className="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-background to-transparent" />
    )}
  </div>
  ```
- **Show More/Less Controls**: Use chevron icons (ChevronDown/ChevronUp) with descriptive text for expand/collapse actions
- **Consistent Collapsed Heights**: Match collapsed heights to related UI sections (e.g., prediction summary height)

### Layout & Spacing Standards
Follow these consistent spacing patterns for professional, polished layouts:

**Page Sections:**
- Use semantic `<section>` elements for major content areas
- **Section spacing**: `mb-24` (6rem/96px) between major sections
- **Hero sections**: `py-16` (4rem/64px) vertical padding, `mb-24` bottom margin
- **Section dividers**: `my-16` (4rem/64px) margin for border separators

**Content Spacing:**
- **Page titles (H1)**: `mb-6` (1.5rem/24px) bottom margin
- **Section titles (H2)**: `mb-6` (1.5rem/24px) bottom margin 
- **Content blocks**: `mb-12` (3rem/48px) between content areas within sections
- **Call-to-action elements**: `mt-8` (2rem/32px) top margin for secondary actions

**Container Structure:**
```jsx
// Standard page layout
<main className="container mx-auto px-4 py-8">
  <section className="py-16 mb-24"> {/* Hero */}
    <h1 className="mb-6">Page Title</h1>
    <p>Description</p>
  </section>
  
  <section className="mb-24"> {/* Content section */}
    <div className="text-center mb-12">
      <h2 className="mb-6">Section Title</h2>
      <p>Section description</p>
    </div>
    {/* Section content */}
  </section>
</main>
```

**Best Practices:**
- **Consistency**: Always use the same spacing values across similar elements
- **Breathing room**: Generous spacing prevents cramped layouts and improves readability
- **Visual hierarchy**: Larger spacing between major sections, smaller spacing within sections
- **Responsive**: Tailwind spacing classes automatically scale appropriately on mobile

### Running the development server
- If the development server port localhost:3000 is already in use, please do not try to start another development server automatically. Ask first before starting another development server.

### Testing Cron Endpoints
- Use `Authorization: Bearer $CRON_SECRET` header when testing cron endpoints manually
- Example: `curl -H "Authorization: Bearer your-secret" http://localhost:3000/api/cron/endpoint-name`
- Extract CRON_SECRET from .env.local: `grep CRON_SECRET .env.local | cut -d'"' -f2`

### Testing Vercel Cron Jobs Locally
To test the exact same authentication that Vercel Cron will use in production:
```bash
# Extract secret from environment
CRON_SECRET=$(grep CRON_SECRET .env.local | cut -d'"' -f2)

# Test exactly like Vercel Cron will call it
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/daily-update-polymarket-data
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/daily-generate-batch-predictions
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/prediction-check
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/update-ai-models
```

## Database Guidelines
- Wait for user confirmation before moving forward with changes to the Database schema. Ask for user confirmation before moving forward.
- Always use Prisma queries from `lib/db/queries.ts`
- Add new queries to the appropriate query object
- Use transactions for multi-step database operations
- Follow the existing schema patterns (snake_case for DB columns, camelCase for JS)
- Try to use the migration commands in package.json such as "db:migrate:deploy:dev"
- **Prefer simple queries** - Complex joins can be hard to debug for a solo developer

### Prisma & Serialization Best Practices
- **Prisma JSON Protocol**: Schema uses `jsonProtocol = "true"` to return plain objects instead of Decimal instances
- **Server-to-Client Serialization**: Always use `serializeDecimals()` from `lib/serialization.ts` when passing Prisma data to Client Components
- **API Routes**: Serialize all Prisma responses with `serializeDecimals()` before returning JSON
- **Migration Pattern**: Run `pnpm prisma generate` after schema changes to regenerate client with JSON protocol
- **Error Pattern**: "Only plain objects can be passed to Client Components" = missing serialization
- **Centralized Serialization**: Use `*Serialized` query wrappers (e.g., `getMarketByIdSerialized`) to avoid repeating serialization logic
- **DTO Types**: Define client-safe DTO interfaces in `lib/types.ts` with plain JSON types (numbers, ISO strings) to catch serialization issues early
- **Build-Safe Imports**: Never import from `@prisma/client/runtime/library` at module level - use runtime detection patterns to avoid webpack build errors
### Database Operations
- Use commands in package.json where possible for database migration in Dev and Preview builds.

## API Design
- Use Next.js API routes in `app/api/`
- All cron endpoints (`/api/cron/*`) must require authentication via `CRON_SECRET`
- Use `Authorization: Bearer $CRON_SECRET` header for cron authentication
- Implement maximum batch limits (typically 50-100) to prevent resource exhaustion
- Return consistent `ApiResponse` format
- Include proper error handling and logging
- Use appropriate HTTP status codes
- **Start simple** - Use basic patterns that are easy to debug and maintain

## Raw Data Storage
- Store raw API responses in separate `_raw` tables
- Use JSON columns for raw response data
- Include metadata: marketId, eventId, apiEndpoint, responseStatus, fetchedAt
- Keep raw data for historical purposes only
- Use the canonical `markets` table for application logic

## File Organization
- Components: `components/` (reusable) and `app/` (page-specific)
- Services: `lib/services/` for business logic
- Database: `lib/db/` for queries and schema
- Types: `lib/types.ts` for shared interfaces
- Utils: `lib/utils.ts` for helper functions

## Error Handling
- Use try-catch blocks with proper error logging
- Return structured error responses
- Include meaningful error messages for debugging
- **Keep error handling simple** - Don't over-engineer for edge cases

## Performance Considerations
- Use database indexes for common query patterns
- Implement proper caching strategies
- Optimize API calls with rate limiting
- Clean up old raw data periodically
- **Optimize when needed** - Don't pre-optimize for a solo founder project

## Security
- Validate all user inputs
- Use environment variables for sensitive data
- Implement proper authentication for cron jobs
- Sanitize data before database operations
- **Start with basic security** - Add advanced features as needed

## Testing
- Write unit tests for business logic
- Test API endpoints with proper error cases
- Validate database operations
- **Keep testing practical** - Focus on critical paths for a solo founder

## Documentation
- Be concise where possible
- Add JSDoc comments for complex functions
- Add at least a single line comment to explain each major section of code.
- Update README.md for new features
- Document API endpoints and data structures

## Environment Variables
- Always leverage .env.local instead of .env. Do not create a .env file.
- Update .env.example to include new variables.
- **NEVER** pull down production environment variables automatically. Always ask the user for specific values if production env vars are needed.
- Use development environment variables by default: `vercel env pull .env.local --environment=development`

## General Guidance
- Use best practices where possible.
- Prefer minimal code where possible.
- Prefer using existing popular libraries and frameworks for solutions rather than custom code where possible. Please suggest and ask for feedback where existing libraries can be used.
- **Solo Founder Approach**: Prefer simple, maintainable solutions over complex architectures
- **Start simple, scale later**: Don't over-engineer for future needs that may never come

# Appendix
- Feel free to throw in a quote from the movie the Big Lebowski or Forest Gump when relevant.
- Feel free to provide additional feedback, guidance if you see issues with the current design or code.