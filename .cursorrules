# Cursor AI Configuration for BetterAI Project

## Project Overview
This is a Next.js prediction market application built by a **solo founder** that integrates with Polymarket and Colosseum APIs. The app uses Prisma with PostgreSQL for data management.

**Infrastructure:** The entire application runs on Vercel infrastructure, including hosting, serverless functions, and database connections. Please see RUNBOOK.md for more information.



## High level guidance to Claude on coding and design
**Solo Founder Context**: This project is built and maintained by a single developer. Prioritize:
- **Simplicity over complexity** - Choose straightforward solutions that are easy to maintain
- **Less code is better** - Choose solutions that involve less custom code where possible.
- **Proven technologies** - Use well-established libraries and patterns
- **Minimal dependencies** - Avoid over-engineering for a 1-person team
- **Clear documentation** - Write code that's easy to understand and modify later
- **Gradual scaling** - Start simple, optimize later when needed


## Code Style & Patterns
- Use TypeScript with strict typing
- Follow Next.js 14+ App Router patterns
- Use Prisma for database operations
- Prefer functional components with hooks
- Use shadcn/ui components for UI consistency
- Follow the existing file structure and naming conventions
- **Keep it simple** - Avoid over-engineering for a solo founder project

### UI/UX Patterns
- **Collapsible Content with Gradient Fade**: For long text content that needs to be collapsed, use gradient fade effects to indicate there's more content below:
  ```jsx
  // Collapsed content with fade effect
  <div className={cn(
    "relative overflow-hidden",
    !expanded && "max-h-[5rem]"
  )}>
    {content}
    {!expanded && (
      <div className="absolute bottom-0 left-0 right-0 h-6 bg-gradient-to-t from-background to-transparent" />
    )}
  </div>
  ```
- **Show More/Less Controls**: Use chevron icons (ChevronDown/ChevronUp) with descriptive text for expand/collapse actions
- **Consistent Collapsed Heights**: Match collapsed heights to related UI sections (e.g., prediction summary height)

### Running the development server
- If the development server port localhost:3000 is already in use, please do not try to start another development server automatically. Ask first before starting another development server.

### Testing Cron Endpoints
- Use `Authorization: Bearer $CRON_SECRET` header when testing cron endpoints manually
- Example: `curl -H "Authorization: Bearer your-secret" http://localhost:3000/api/cron/endpoint-name`
- Extract CRON_SECRET from .env.local: `grep CRON_SECRET .env.local | cut -d'"' -f2`

### Testing Vercel Cron Jobs Locally
To test the exact same authentication that Vercel Cron will use in production:
```bash
# Extract secret from environment
CRON_SECRET=$(grep CRON_SECRET .env.local | cut -d'"' -f2)

# Test exactly like Vercel Cron will call it
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/daily-update-polymarket-data
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/daily-generate-batch-predictions
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/prediction-check
curl -H "Authorization: Bearer $CRON_SECRET" http://localhost:3000/api/cron/update-ai-models
```

## Database Guidelines
- Wait for user confirmation before moving forward with changes to the Database schema. Ask for user confirmation before moving forward.
- Always use Prisma queries from `lib/db/queries.ts`
- Add new queries to the appropriate query object
- Use transactions for multi-step database operations
- Follow the existing schema patterns (snake_case for DB columns, camelCase for JS)
- Try to use the migration commands in package.json such as "db:migrate:deploy:dev"
- **Prefer simple queries** - Complex joins can be hard to debug for a solo developer
### Database Operations
- Use commands in package.json where possible for database migration in Dev and Preview builds.

## API Design
- Use Next.js API routes in `app/api/`
- All cron endpoints (`/api/cron/*`) must require authentication via `CRON_SECRET`
- Use `Authorization: Bearer $CRON_SECRET` header for cron authentication
- Implement maximum batch limits (typically 50-100) to prevent resource exhaustion
- Return consistent `ApiResponse` format
- Include proper error handling and logging
- Use appropriate HTTP status codes
- **Start simple** - Use basic patterns that are easy to debug and maintain

## Raw Data Storage
- Store raw API responses in separate `_raw` tables
- Use JSON columns for raw response data
- Include metadata: marketId, eventId, apiEndpoint, responseStatus, fetchedAt
- Keep raw data for historical purposes only
- Use the canonical `markets` table for application logic

## File Organization
- Components: `components/` (reusable) and `app/` (page-specific)
- Services: `lib/services/` for business logic
- Database: `lib/db/` for queries and schema
- Types: `lib/types.ts` for shared interfaces
- Utils: `lib/utils.ts` for helper functions

## Error Handling
- Use try-catch blocks with proper error logging
- Return structured error responses
- Include meaningful error messages for debugging
- **Keep error handling simple** - Don't over-engineer for edge cases

## Performance Considerations
- Use database indexes for common query patterns
- Implement proper caching strategies
- Optimize API calls with rate limiting
- Clean up old raw data periodically
- **Optimize when needed** - Don't pre-optimize for a solo founder project

## Security
- Validate all user inputs
- Use environment variables for sensitive data
- Implement proper authentication for cron jobs
- Sanitize data before database operations
- **Start with basic security** - Add advanced features as needed

## Testing
- Write unit tests for business logic
- Test API endpoints with proper error cases
- Validate database operations
- **Keep testing practical** - Focus on critical paths for a solo founder

## Documentation
- Be concise where possible
- Add JSDoc comments for complex functions
- Add at least a single line comment to explain each major section of code.
- Update README.md for new features
- Document API endpoints and data structures

## Environment Variables
- Always leverage .env.local instead of .env. Do not create a .env file.
- Update .env.example to include new variables.
- **NEVER** pull down production environment variables automatically. Always ask the user for specific values if production env vars are needed.
- Use development environment variables by default: `vercel env pull .env.local --environment=development`

## General Guidance
- Use best practices where possible.
- Prefer minimal code where possible.
- Prefer using existing popular libraries and frameworks for solutions rather than custom code where possible. Please suggest and ask for feedback where existing libraries can be used.
- **Solo Founder Approach**: Prefer simple, maintainable solutions over complex architectures
- **Start simple, scale later**: Don't over-engineer for future needs that may never come

# Appendix
- Feel free to throw in a quote from the movie the Big Lebowski or Forest Gump when relevant.
- Feel free to provide additional feedback, guidance if you see issues with the current design or code.